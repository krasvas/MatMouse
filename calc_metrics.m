%     MatMouse toolbox
%     Copyright (C) 2020 Vassilios Krassanakis, Anastasios Kesidis
%
%     This program is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
%
%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.
%
%     You should have received a copy of the GNU General Public License
%     along with this program.  If n    ot, see <http://www.gnu.org/licenses/>.
%
%     For further information, please email Vassilios Krassanakis:
%     krasvas@uniwa.gr (University of West Attica)

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Function calc_metrics
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% --- Description ---
% Provides statistics regarding the recorder trajectory as well as its
% comparison to the optimal trajectory.
% --- Syntax ---
% [react,len,tstat,lineq,dstat,charea]=calc_metrics(A)
% --- Input parameters ---
% A: An array A containing the tracked mouse movements of a trajectory. It
% can be given by functions movement_track or movement_track_seq.
% --- Output parameters ---
% react: total reaction time in sec
% len: total trajectory length in pixels
% tstat: structure of trajectory direction angle statistics (in degrees).
% The structure fields are:
%    tstat.avg: average
%    tstat.std: standard deviation
%    tstat.min: min value
%    tstat.max: max value
%    tstat.range: range of values
% lineq: structure with the coefficients (a,b and c) of the line equation
% ax+by+c=0 describing the optimal trajectory. The line is calculated from
% the starting and ending trajectory points. The structure fields are:
%    lineq.a: line parameter a
%    lineq.b: line parameter b
%    lineq.c: line parameter c
% dstat: structure of distance based (from the optimal trajectory)
% statistics. The structure fields are:
%    dstat.avg: average
%    dstat.std: standard deviation
%    dstat.min: min value
%    dstat.max: max value
%    dstat.range: range of values
% charea: Convex hull area (in pixels) generated by the recorder trajectory.
% --- Example ---
% [react,len,tstat,lineq,dstat,charea]=calc_metrics(A)

function [react,len,uniq,lineq,dstat,charea,curv]=calc_metrics(A)

dbstop if error;
dbstop if warning;

DataWindowWidth=13;
CurvatureWindowWidth=19;
% Mouse movements coordinates
[~,Idx]=unique([A.x A.y],'rows','stable');

x=A.x(Idx);
y=A.y(Idx);
dur=diff([A.t(Idx);A.t(end)]);

% Coordinates of starting and ending point
n=length(x);
x_start=x(1);
y_start=y(1);
x_end=x(n);
y_end=y(n);

% Total reaction time
react=A.t(end)-A.t(1); % in sec

% Total trajectory length (in pixels)
len=0;
for i=2:n
    %length
    d=sqrt(((x(i)-x(i-1))^2)+((y(i)-y(i-1))^2));
    len=len+d;
end

% Unique mouse coordinates and the corresponding durations
uniq.d=dur;
uniq.x=x;
uniq.y=y;

% Compute the coefficients (a, b and c) of the line equation
% a*x+b*y+c=0 generated by starting and ending point
lineq.a=y_start-y_end;
lineq.b=x_end-x_start;
lineq.c=(x_start*y_end)-(x_end*y_start);

% Distance between each mouse point and start-end line
distances_mouse_points=zeros(n,1);
for i=1:n
    % calculate distance
    distances_mouse_points(i)=(abs((lineq.a*x(i))+(lineq.b*y(i))+lineq.c))/(sqrt((lineq.a^2)+(lineq.b^2)));
end

% Basic statistics on distances (after removing start and end point)
dstat.avg=mean(distances_mouse_points(2:(n-1)));
dstat.std=std(distances_mouse_points(2:(n-1)));
dstat.min=min(distances_mouse_points(2:(n-1)));
dstat.max=max(distances_mouse_points(2:(n-1)));
dstat.range=dstat.max-dstat.min;

% Convex hull area
if length(x)>2
    cvh_area_index=convhull(x,y);
    charea= polyarea(x(cvh_area_index),y(cvh_area_index)); %in pixels
else
    charea=[];
end

% Curvature
curv=calc_curvature(uniq.x,uniq.y,DataWindowWidth,CurvatureWindowWidth);

    function f=calc_curvature(x,y,DataWindowWidth,CurvatureWindowWidth)
        
        % Smooth with a Savitzky-Golay sliding polynomial filter
        PolynomialOrder = 2;
        
        sx = sgolayfilt(x, PolynomialOrder, DataWindowWidth);
        sy = sgolayfilt(y, PolynomialOrder, DataWindowWidth);
        
        % Calc curvature
        N=length(x);
        Curvature=zeros(N,1);
        for t=2:N-1
            % Get the 3 points
            x1=sx(t-1);
            y1=sy(t-1);
            x2=sx(t);
            y2=sy(t);
            x3=sx(t+1);
            y3=sy(t+1);
            
            % Curvature by Roger's formula
            % see https://hratliff.com/posts/2019/02/curvature-of-three-points/
            Curvature(t) = 2*abs((x2-x1).*(y3-y2)-(y2-y1).*(x3-x2)) ./ ...
                sqrt(((x2-x1).^2+(y2-y1).^2)*((x3-x1).^2+(y3-y1).^2)*((x3-x2).^2+(y3-y2).^2));
        end
        
        % Smooth the curvature values
        sCurvature=sgolayfilt(Curvature,PolynomialOrder,CurvatureWindowWidth);
        
        % Correct to zero any negative values
        sCurvature(sCurvature<0)=0;
        
        f=sCurvature;
    end

end